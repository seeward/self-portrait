/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TextureLoader, FileLoader, ImageLoader, ObjectLoader } from 'three';
import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
export default class Loaders {
    constructor(cache, textureAnisotropy) {
        this.cache = cache;
        this.textureAnisotropy = textureAnisotropy;
    }
    get fileLoader() {
        if (!this._fileLoader)
            this._fileLoader = new FileLoader();
        return this._fileLoader;
    }
    get imageLoader() {
        if (!this._imgLoader)
            this._imgLoader = new ImageLoader();
        return this._imgLoader;
    }
    get svgLoader() {
        if (!this._svgLoader)
            this._svgLoader = new SVGLoader();
        return this._svgLoader;
    }
    get textureLoader() {
        if (!this._textureLoader)
            this._textureLoader = new TextureLoader();
        return this._textureLoader;
    }
    get objectLoader() {
        if (!this._objectLoader)
            this._objectLoader = new ObjectLoader();
        return this._objectLoader;
    }
    get gltfLoader() {
        if (!this._gltfLoader)
            this._gltfLoader = new GLTFLoader();
        return this._gltfLoader;
    }
    get fbxLoader() {
        if (!this._fbxLoader)
            this._fbxLoader = new FBXLoader();
        return this._fbxLoader;
    }
    preload(key, url) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cache.add(key, url);
            return new Promise(resolve => {
                const isModel = /\.fbx$|\.glb$|\.gltf$/.test(url);
                const isTexture = /\.jpe?g$|\.png$/.test(url);
                if (isTexture) {
                    this.textureLoader.load(url, texture => {
                        return resolve(texture);
                    });
                }
                else {
                    if (isModel)
                        this.fileLoader.setResponseType('arraybuffer');
                    this.fileLoader.load(url, file => {
                        return resolve(file);
                    });
                }
            });
        });
    }
    textureAtlas(texture, json, _type = 'JSONHash') {
        return __awaiter(this, void 0, void 0, function* () {
            let parsed = JSON.parse((yield this.file(json)));
            // convert JSONArray to JSONHash
            const isJSONArray = parsed.textures;
            if (isJSONArray) {
                const frames = parsed.textures[0].frames;
                let jsonHash = { frames: {} };
                frames.forEach(frame => {
                    jsonHash = Object.assign(Object.assign({}, jsonHash), { frames: Object.assign(Object.assign({}, jsonHash.frames), { [frame.filename]: {
                                frame: frame.frame,
                                rotated: frame.rotated,
                                sourceSize: frame.sourceSize,
                                spriteSourceSize: frame.spriteSourceSize,
                                trimmed: frame.trimmed
                            } }) });
                });
                parsed = jsonHash;
            }
            const atlas = {
                texture: yield this.texture(texture),
                json: parsed
            };
            return atlas;
        });
    }
    file(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fileLoader.load(url, file => {
                return resolve(file);
            });
        });
    }
    svg(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.svgLoader.load(url, svg => {
                return resolve(svg);
            });
        });
    }
    texture(paramOne, paramTwo) {
        let url = paramTwo !== null && paramTwo !== void 0 ? paramTwo : paramOne;
        let key = paramTwo ? paramOne : undefined;
        const isBase64 = /^data:image\/[\S]+;base64,/gm.test(url);
        // we do not want to cache base64 images
        if (!isBase64) {
            const key = this.cache.get(url);
            url = key ? key : url;
        }
        return new Promise(resolve => {
            this.textureLoader.load(url, (texture) => {
                if (key)
                    this.cache.add(key, texture);
                texture.anisotropy = this.textureAnisotropy;
                texture.needsUpdate = true;
                resolve(texture);
            });
        });
    }
    // examples: https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4
    object(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.objectLoader.load(url, (json) => {
                resolve(json);
            });
        });
    }
    gltf(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.gltfLoader.load(url, (gltf) => {
                resolve(gltf);
            });
        });
    }
    fbx(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fbxLoader.load(url, (fbx) => {
                resolve(fbx);
            });
        });
    }
}
//# sourceMappingURL=loaders.js.map