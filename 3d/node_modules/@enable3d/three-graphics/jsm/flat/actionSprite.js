/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
import { SimpleSprite } from './simpleSprite';
import { EventEmitter } from 'eventemitter3';
export class ActionSprite extends SimpleSprite {
    constructor(texture) {
        super(texture);
        this._anims = [];
        this._flipX = false;
        this.currentIndex = 0;
        this.currentAnimation = '';
        this.currentFrameWidth = 0;
        this.currentFrameHeight = 0;
    }
    getAnimationByKey(key) {
        return this._anims.filter(a => a.key === key)[0];
    }
    _add(key, frameOptions) {
        const { start, end, rate = 30, repeat = -1, timeline = [] } = frameOptions;
        if (this.getAnimationByKey(key)) {
            console.warn(`The animation "${key}" does already exist!`);
            return;
        }
        if (timeline.length === 0) {
            if (typeof end === 'undefined' || typeof start === 'undefined') {
                console.warn(`You need to provide "start" and "end or a "timeline"!`);
                return;
            }
            for (let i = start; i <= end; i++) {
                timeline.push(i);
            }
        }
        this._anims.push({ key, timeline, rate, repeat });
    }
    _stop() {
        if (this.interval)
            clearInterval(this.interval);
    }
    _play(key) {
        this._stop();
        this.currentAnimation = key;
        const animation = this.getAnimationByKey(key);
        if (!animation)
            console.warn(`Animation "${key}" does not exist!`);
        const { timeline, rate, repeat } = animation;
        this.currentIndex = -1;
        let loops = 0;
        const playNextFrame = () => {
            this.currentIndex++;
            if (this.currentIndex >= timeline.length) {
                this.currentIndex = 0;
                loops++;
            }
            this.currentFrame = timeline[this.currentIndex];
            const shouldStop = !(repeat === -1 || loops < repeat);
            if (shouldStop) {
                this._stop();
                this._events.emit('complete');
                return;
            }
            this.setFrame(this.currentFrame);
        };
        playNextFrame();
        this.interval = window.setInterval(() => {
            playNextFrame();
        }, 1000 / rate);
        return { onComplete: (cb) => this._events.once('complete', cb) };
    }
    get _events() {
        return {
            emit: (event) => {
                if (!this._eventEmitter)
                    this._eventEmitter = new EventEmitter();
                this._eventEmitter.emit(event);
            },
            once: (event, callback) => {
                if (!this._eventEmitter)
                    this._eventEmitter = new EventEmitter();
                this._eventEmitter.once(event, callback);
            }
        };
    }
    get anims() {
        return {
            add: this._add.bind(this),
            play: this._play.bind(this),
            stop: this._stop.bind(this),
            setFrame: this.setFrame.bind(this),
            getFrame: () => this.currentFrame
        };
    }
}
//# sourceMappingURL=actionSprite.js.map