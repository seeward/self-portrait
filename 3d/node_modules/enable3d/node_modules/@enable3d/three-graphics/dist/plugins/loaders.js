"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("@enable3d/three-wrapper/dist/index");
class Loaders {
    constructor(cache, textureAnisotropy) {
        this.cache = cache;
        this.textureAnisotropy = textureAnisotropy;
    }
    get fileLoader() {
        if (!this._fileLoader)
            this._fileLoader = new index_1.FileLoader();
        return this._fileLoader;
    }
    get imageLoader() {
        if (!this._imgLoader)
            this._imgLoader = new index_1.ImageLoader();
        return this._imgLoader;
    }
    get svgLoader() {
        if (!this._svgLoader)
            this._svgLoader = new index_1.SVGLoader();
        return this._svgLoader;
    }
    get textureLoader() {
        if (!this._textureLoader)
            this._textureLoader = new index_1.TextureLoader();
        return this._textureLoader;
    }
    get objectLoader() {
        if (!this._objectLoader)
            this._objectLoader = new index_1.ObjectLoader();
        return this._objectLoader;
    }
    get gltfLoader() {
        if (!this._gltfLoader)
            this._gltfLoader = new index_1.GLTFLoader();
        return this._gltfLoader;
    }
    get fbxLoader() {
        if (!this._fbxLoader)
            this._fbxLoader = new index_1.FBXLoader();
        return this._fbxLoader;
    }
    preload(key, url) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cache.add(key, url);
            return new Promise(resolve => {
                const isModel = /\.fbx$|\.glb$|\.gltf$/.test(url);
                const isTexture = /\.jpe?g$|\.png$/.test(url);
                if (isTexture) {
                    this.textureLoader.load(url, texture => {
                        return resolve(texture);
                    });
                }
                else {
                    if (isModel)
                        this.fileLoader.setResponseType('arraybuffer');
                    this.fileLoader.load(url, file => {
                        return resolve(file);
                    });
                }
            });
        });
    }
    file(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fileLoader.load(url, file => {
                return resolve(file);
            });
        });
    }
    svg(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.svgLoader.load(url, svg => {
                return resolve(svg);
            });
        });
    }
    texture(url) {
        const isBase64 = /^data:image\/[\S]+;base64,/gm.test(url);
        // we do not want to cache base64 images
        if (!isBase64) {
            const key = this.cache.get(url);
            url = key ? key : url;
        }
        return new Promise(resolve => {
            this.textureLoader.load(url, (texture) => {
                // options
                texture.anisotropy = this.textureAnisotropy;
                texture.format = index_1.RGBAFormat;
                texture.needsUpdate = true;
                resolve(texture);
            });
        });
    }
    // examples: https://github.com/mrdoob/three.js/wiki/JSON-Object-Scene-format-4
    object(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.objectLoader.load(url, (json) => {
                resolve(json);
            });
        });
    }
    gltf(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.gltfLoader.load(url, (gltf) => {
                resolve(gltf);
            });
        });
    }
    fbx(url) {
        const key = this.cache.get(url);
        url = key ? key : url;
        return new Promise(resolve => {
            this.fbxLoader.load(url, (fbx) => {
                resolve(fbx);
            });
        });
    }
}
exports.default = Loaders;
//# sourceMappingURL=loaders.js.map