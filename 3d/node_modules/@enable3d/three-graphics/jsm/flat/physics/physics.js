/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
import { Engine, World, Runner, Bodies, Body, Vertices, Render, Events, Vector } from 'matter-js';
import { Vector2 } from 'three';
import { adjustDebugColor } from './_misc';
export class Physics {
    constructor(debug = true) {
        this._objects = new Map();
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        const DEBUG = debug;
        this.engine = Engine.create({ enableSleeping: true });
        this.world = this.engine.world;
        this.runner = Runner.create();
        // for debugging
        if (DEBUG) {
            const canvas = document.createElement('canvas');
            canvas.id = 'matter-debug';
            canvas.style.position = 'absolute';
            canvas.style.top = '0px';
            canvas.style.left = '0px';
            canvas.style.pointerEvents = 'none';
            document.body.append(canvas);
            this.render = Render.create({
                canvas: canvas,
                engine: this.engine,
                options: {
                    width: this.width,
                    height: this.height,
                    background: 'transparent',
                    wireframeBackground: 'transparent',
                    wireframes: false,
                    showConvexHulls: true,
                    showPositions: true,
                    showVelocity: true
                }
            });
            Render.run(this.render);
        }
        Runner.run(this.runner, this.engine);
        Events.on(this.engine, 'afterUpdate', () => this.update());
    }
    parsePhysics(file) {
        const json = JSON.parse(file);
        delete json['generator_info'];
        let bodies = {};
        for (const key in json) {
            const fixtures = json[key].fixtures;
            bodies = Object.assign(Object.assign({}, bodies), { [key]: fixtures });
        }
        return bodies;
    }
    addBodyFromFixtures(x, y, fixtures) {
        const bodies = [];
        fixtures.forEach(fixture => {
            let body;
            if (fixture.vertices) {
                body = this.add.fromVertices(x, y, fixture.vertices);
            }
            else if (fixture.circle) {
                body = this.add.circle(x + fixture.circle.x, y + fixture.circle.y, fixture.circle.radius);
            }
            else {
                console.log(`Shape not recognized!`);
            }
            if (body)
                bodies.push(body);
        });
        let body;
        if (bodies.length > 1)
            body = Body.create({
                parts: bodies
            });
        else
            body = bodies[0];
        Body.setPosition(body, { x, y });
        return body;
    }
    fromVertices_Fixed(x, y, vertexSets, options = {}) {
        // https://github.com/liabru/matter-js/issues/248#issuecomment-361983251
        const bodies = [];
        for (var i = 0; i < vertexSets.length; i++) {
            const body = Bodies.fromVertices(x, y, [vertexSets[i]], Object.assign({}, options));
            bodies.push(body);
            const centre = Vertices.centre(vertexSets[i]);
            Body.setPosition(body, {
                x: body.position.x + centre.x,
                y: body.position.y + centre.y
            });
        }
        const compound = Body.create(Object.assign(Object.assign({}, options), { parts: bodies }));
        return compound;
    }
    fromVertices(x, y, vertexSets, options = {}) {
        return this.fromVertices_Fixed(x, y, vertexSets, Object.assign({}, options));
    }
    setBounds(x = 0, y = 0, width = this.width, height = this.height, depth = 50) {
        // x = 100
        // y = 100
        // width = 300
        // height = 500
        // walls
        World.add(this.world, [
            // top
            this.add.rectangle(x + width / 2, y + 0 - depth / 2, width + depth * 2, depth, { isStatic: true }),
            // bottom
            this.add.rectangle(x + width / 2, y + height + depth / 2, width + depth * 2, depth, { isStatic: true }),
            // left
            this.add.rectangle(x + 0 - depth / 2, y + height / 2, depth, height + depth * 2, { isStatic: true }),
            // right
            this.add.rectangle(x + width + depth / 2, y + height / 2, depth, height + depth * 2, { isStatic: true })
        ]);
    }
    rectangle(x, y, width, height, options = {}) {
        return Bodies.rectangle(x, y, width, height, Object.assign({}, options));
    }
    circle(x, y, radius, options = {}) {
        return Bodies.circle(x, y, radius, Object.assign({}, options));
    }
    existing(sprite) {
        this.add.bodyToSprite(sprite);
        this._objects.set(sprite.body.id.toString(), sprite);
    }
    calcBodyOffset(sprite) {
        const body = sprite.body;
        // https://github.com/liabru/matter-js/issues/211#issuecomment-184804576
        const width = body.bounds.max.x - body.bounds.min.x;
        const height = body.bounds.max.y - body.bounds.min.y;
        const topLeft = Vector.sub(body.bounds.min, body.position);
        const centerOfBody = { x: width / 2, y: height / 2 };
        const centerOfMass = body.position;
        const offsetX = topLeft.x + width / 2;
        const offsetY = topLeft.y + height / 2;
        const offset = { x: offsetX, y: offsetY };
        sprite._bodyOffset = offset;
    }
    _addBodyToSprite(sprite) {
        this.add.body(sprite.body);
        this.calcBodyOffset(sprite);
        sprite.setBodyPosition = (x, y) => {
            Body.setPosition(sprite.body, {
                x: x - sprite._bodyOffset.x,
                y: y - sprite._bodyOffset.y
            });
        };
    }
    _addBody(body) {
        World.add(this.world, body);
    }
    get add() {
        return {
            body: this._addBody.bind(this),
            bodyToSprite: this._addBodyToSprite.bind(this),
            fromVertices: this.fromVertices.bind(this),
            circle: this.circle.bind(this),
            existing: this.existing.bind(this),
            rectangle: this.rectangle.bind(this)
        };
    }
    adjustDebugColor(body) {
        adjustDebugColor(body);
    }
    update() {
        this._objects.forEach(object => {
            const { body } = object;
            const { angle, position } = body;
            const { x, y } = position;
            // https://github.com/liabru/matter-js/issues/211#issuecomment-184804576
            const offset = new Vector2(object._bodyOffset.x, object._bodyOffset.y);
            offset.rotateAround(new Vector2(), angle);
            object.setPosition(x + offset.x, this.height - y - offset.y);
            object.setRotation(-angle);
            adjustDebugColor(body);
        });
    }
}
//# sourceMappingURL=physics.js.map