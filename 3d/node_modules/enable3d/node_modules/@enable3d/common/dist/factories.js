"use strict";
/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|GNU GPLv3}
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("@enable3d/three-wrapper/dist/index");
const extendedMesh_1 = require("./extendedMesh");
const logger_1 = require("./logger");
const defaultMaterial_1 = require("./defaultMaterial");
class Factories {
    constructor(scene) {
        this.scene = scene;
        this.isHeadless = scene === 'headless' ? true : false;
        this.defaultMaterial = new defaultMaterial_1.default();
    }
    get make() {
        return {
            plane: (planeConfig = {}, materialConfig = {}) => this.makePlane(planeConfig, materialConfig),
            box: (boxConfig = {}, materialConfig = {}) => this.makeBox(boxConfig, materialConfig),
            sphere: (sphereConfig = {}, materialConfig = {}) => this.makeSphere(sphereConfig, materialConfig),
            cylinder: (cylinderConfig = {}, materialConfig = {}) => this.makeCylinder(cylinderConfig, materialConfig),
            cone: (coneConfig = {}, materialConfig = {}) => this.makeCone(coneConfig, materialConfig),
            torus: (torusConfig = {}, materialConfig = {}) => this.makeTorus(torusConfig, materialConfig),
            extrude: (extrudeConfig, materialConfig = {}) => this.makeExtrude(extrudeConfig, materialConfig)
        };
    }
    get add() {
        return {
            // effectComposer: () => this.addEffectComposer(),
            mesh: (mesh) => this.addMesh(mesh),
            // group: (...children) => this.addGroup(children),
            existing: (object) => this.addExisting(object),
            //  Geometry
            plane: (planeConfig = {}, materialConfig = {}) => this.addPlane(planeConfig, materialConfig),
            box: (boxConfig = {}, materialConfig = {}) => this.addBox(boxConfig, materialConfig),
            ground: (groundConfig, materialConfig = {}) => this.addGround(groundConfig, materialConfig),
            //...
            sphere: (sphereConfig = {}, materialConfig = {}) => this.addSphere(sphereConfig, materialConfig),
            cylinder: (cylinderConfig = {}, materialConfig = {}) => this.addCylinder(cylinderConfig, materialConfig),
            cone: (coneConfig = {}, materialConfig = {}) => this.addCone(coneConfig, materialConfig),
            torus: (torusConfig = {}, materialConfig = {}) => this.addTorus(torusConfig, materialConfig),
            extrude: (extrudeConfig, materialConfig = {}) => this.addExtrude(extrudeConfig, materialConfig),
            //...
            material: (materialConfig = {}) => this.addMaterial(materialConfig)
        };
    }
    addExisting(...object) {
        if (this.scene === 'headless')
            return;
        this.scene.add(...object);
    }
    addMesh(mesh) {
        if (Array.isArray(mesh)) {
            for (let i = 0; i < mesh.length; i++) {
                this.addExisting(mesh[i]);
            }
        }
        else {
            this.addExisting(mesh);
        }
        return this;
    }
    createMesh(geometry, material, position) {
        const { x = 0, y = 0, z = 0 } = position;
        let obj;
        switch (!Array.isArray(material) && material.type) {
            case 'LineBasicMaterial':
                obj = new index_1.Line(geometry, material);
                break;
            case 'PointsMaterial':
                obj = new index_1.Points(geometry, material);
                break;
            default:
                obj = new extendedMesh_1.ExtendedMesh(geometry, material);
                break;
        }
        obj.position.set(x, y, z);
        obj.castShadow = obj.receiveShadow = true;
        return obj;
    }
    makeExtrude(extrudeConfig, materialConfig) {
        const { x, y, z, name, shape, autoCenter = true, breakable = false, bufferGeometry = true } = extrudeConfig, rest = __rest(extrudeConfig
        // @ts-ignore // ExtrudeGeometryOptions interface missing since three.js r121
        , ["x", "y", "z", "name", "shape", "autoCenter", "breakable", "bufferGeometry"]);
        // @ts-ignore // ExtrudeGeometryOptions interface missing since three.js r121
        const { depth = 1, bevelEnabled = false } = rest;
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.ExtrudeBufferGeometry(shape, Object.assign({ depth, bevelEnabled }, rest))
            : new index_1.ExtrudeGeometry(shape, Object.assign({ depth, bevelEnabled }, rest));
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        // auto adjust the center for custom shapes
        if (autoCenter)
            mesh.geometry.center();
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'extrude';
        return mesh;
    }
    addExtrude(extrudeConfig, materialConfig = {}) {
        const obj = this.makeExtrude(extrudeConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makePlane(planeConfig, materialConfig) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = planeConfig, rest = __rest(planeConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.PlaneBufferGeometry(rest.width || 1, rest.height || 1, rest.widthSegments || 1, rest.heightSegments || 1)
            : new index_1.PlaneGeometry(rest.width || 1, rest.height || 1, rest.widthSegments || 1, rest.heightSegments || 1);
        const material = this.addMaterial(materialConfig);
        material.side = index_1.DoubleSide;
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'plane';
        return mesh;
    }
    addPlane(planeConfig, materialConfig) {
        const obj = this.makePlane(planeConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeSphere(sphereConfig, materialConfig) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = sphereConfig, rest = __rest(sphereConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.SphereBufferGeometry(rest.radius || 1, rest.widthSegments || 16, rest.heightSegments || 12, rest.phiStart || undefined, rest.phiLength || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined)
            : new index_1.SphereGeometry(rest.radius || 1, rest.widthSegments || 16, rest.heightSegments || 12, rest.phiStart || undefined, rest.phiLength || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'sphere';
        return mesh;
    }
    addSphere(sphereConfig = {}, materialConfig = {}) {
        const obj = this.makeSphere(sphereConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeBox(boxConfig, materialConfig) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = boxConfig, rest = __rest(boxConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.BoxBufferGeometry(rest.width || 1, rest.height || 1, rest.depth || 1, rest.widthSegments || undefined, rest.heightSegments || undefined, rest.depthSegments || undefined)
            : new index_1.BoxGeometry(rest.width || 1, rest.height || 1, rest.depth || 1, rest.widthSegments || undefined, rest.heightSegments || undefined, rest.depthSegments || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'box';
        return mesh;
    }
    addBox(boxConfig = {}, materialConfig = {}) {
        const obj = this.makeBox(boxConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    addGround(groundConfig, materialConfig = {}) {
        const obj = this.makeBox(groundConfig, materialConfig);
        obj.rotateX(index_1.MathUtils.degToRad(90));
        this.addExisting(obj);
        return obj;
    }
    makeCylinder(cylinderConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = cylinderConfig, rest = __rest(cylinderConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.CylinderBufferGeometry(rest.radiusTop || 1, rest.radiusBottom || 1, rest.height || 1, rest.radiusSegments || undefined, rest.heightSegments || undefined, rest.openEnded || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined)
            : new index_1.CylinderGeometry(rest.radiusTop || 1, rest.radiusBottom || 1, rest.height || 1, rest.radiusSegments || undefined, rest.heightSegments || undefined, rest.openEnded || undefined, rest.thetaStart || undefined, rest.thetaLength || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'cylinder';
        return mesh;
    }
    addCylinder(cylinderConfig = {}, materialConfig = {}) {
        const obj = this.makeCylinder(cylinderConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    makeCone(coneConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = coneConfig, rest = __rest(coneConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.ConeBufferGeometry(rest.radius || 1, rest.height || 1, rest.radiusSegments || 8, rest.heightSegments || 1, rest.openEnded || false, rest.thetaStart || 0, rest.thetaLength || 2 * Math.PI)
            : new index_1.ConeBufferGeometry(rest.radius || 1, rest.height || 1, rest.radiusSegments || 8, rest.heightSegments || 1, rest.openEnded || false, rest.thetaStart || 0, rest.thetaLength || 2 * Math.PI);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'cone';
        return mesh;
    }
    addCone(coneConfig = {}, materialConfig = {}) {
        const obj = this.makeCone(coneConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    // https://threejs.org/docs/index.html#api/en/geometries/TorusBufferGeometry
    makeTorus(torusConfig = {}, materialConfig = {}) {
        const { x, y, z, name, breakable = false, bufferGeometry = true } = torusConfig, rest = __rest(torusConfig, ["x", "y", "z", "name", "breakable", "bufferGeometry"]);
        const geometry = bufferGeometry || breakable || this.isHeadless
            ? new index_1.TorusBufferGeometry(rest.radius || undefined, rest.tube || undefined, rest.radialSegments || undefined, rest.tubularSegments || undefined, rest.arc || undefined)
            : new index_1.TorusGeometry(rest.radius || undefined, rest.tube || undefined, rest.radialSegments || undefined, rest.tubularSegments || undefined, rest.arc || undefined);
        const material = this.addMaterial(materialConfig);
        const mesh = this.createMesh(geometry, material, { x, y, z });
        mesh.name = name || `body_id_${mesh.id}`;
        mesh.shape = 'torus';
        return mesh;
    }
    addTorus(torusConfig = {}, materialConfig = {}) {
        const obj = this.makeTorus(torusConfig, materialConfig);
        this.addExisting(obj);
        return obj;
    }
    addMaterial(materialConfig = {}) {
        const type = Object.keys(materialConfig)[0];
        let material;
        // if (type) {
        //   const { map } = materialConfig[type]
        //   if (typeof map === 'string') materialConfig[type].map = this.loadTexture(map)
        // }
        // always share the same material in headless mode to save memory
        if (this.scene === 'headless')
            return this.defaultMaterial.get();
        switch (type) {
            case 'basic':
                material = new index_1.MeshBasicMaterial(materialConfig.basic);
                break;
            case 'normal':
                material = new index_1.MeshNormalMaterial(materialConfig.normal);
                break;
            case 'standard':
                material = new index_1.MeshStandardMaterial(materialConfig.standard);
                break;
            case 'lambert':
                material = new index_1.MeshLambertMaterial(materialConfig.lambert);
                break;
            case 'phong':
                material = new index_1.MeshPhongMaterial(materialConfig.phong);
                break;
            case 'physical':
                if (typeof materialConfig.physical !== 'undefined') {
                    material = new index_1.MeshPhysicalMaterial(materialConfig.physical);
                }
                else {
                    logger_1.default('You need to pass parameters to the physical material. (Fallback to default material)');
                    material = this.defaultMaterial.get();
                }
                break;
            case 'toon':
                material = new index_1.MeshToonMaterial(materialConfig.toon);
                break;
            case 'line':
                material = new index_1.LineBasicMaterial(materialConfig.line);
                break;
            case 'points':
                material = new index_1.PointsMaterial(materialConfig.points);
                break;
            case 'custom':
                material = materialConfig.custom || this.defaultMaterial.get();
                break;
            default:
                material = this.defaultMaterial.get();
                break;
        }
        return material;
    }
}
exports.default = Factories;
//# sourceMappingURL=factories.js.map